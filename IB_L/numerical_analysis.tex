\documentclass[a4paper]{article}

\def\npart {IB}
\def\nterm {Lent}
\def\nyear {2016}
\def\nlecturer {G. Moore}
\def\ncourse {Numerical Analysis}
\def\nlectures {MWF.10}
\def\nofficial {http://www.damtp.cam.ac.uk/user/sjc1/teaching/NAIB/notes.pdf}
 % remove?
\def\nnotready {}

\input{header}

\begin{document}
\maketitle
{\small
\noindent\textbf{Polynomial approximation}\\
Interpolation by polynomials. Divided differences of functions and relations to derivatives. Orthogonal polynomials and their recurrence relations. Least squares approximation by polynomials. Gaussian quadrature formulae. Peano kernel theorem and applications.\hspace*{\fill} [6]

\vspace{10pt}
\noindent\textbf{Computation of ordinary differential equations}\\
Euler's method and proof of convergence. Multistep methods, including order, the root condition and the concept of convergence. Runge-Kutta schemes. Stiff equations and A-stability.\hspace*{\fill} [5]

\vspace{10pt}
\noindent\textbf{Systems of equations and least squares calculations}\\
LU triangular factorization of matrices. Relation to Gaussian elimination. Column pivoting. Factorizations of symmetric and band matrices. The Newton-Raphson method for systems of non-linear algebraic equations. QR factorization of rectangular matrices by Gram-Schmidt, Givens and Householder techniques. Application to linear least squares calculations.\hspace*{\fill} [5]}

\tableofcontents
\setcounter{section}{-1}
\section{Introduction}
What is numerical analysis? It is the study of algorithms. It is about algorithms for solving problems in, say, linear algebra. In the course, you will find that many of the algorithms are named after great figures in the past, like Newton, Euler and Gauss. They have done a lot of work to come up with good algorithms that aids computation. In the past, they had to implement these algorithms by hand, and it makes sense for them to try to simplify them! Nowadays, we are much luckier and have computers to help us solve problems. We can often solve problems by the press of a button.

However, it is also useful to understand how algorithms works, since we might in the future encounter problems with no pre-written solutions by others, and we might need to come up with something ourselves.

\section{Polynomial interpolation}
Polynomials are important. Many many ideas in numerical analysis are based on polynomials approximations, and it is important to understand. The simplest place to start is through polynomial interpolations.

\begin{notation}
  We write $P_n[x]$ for the real linear vector space of polynomials (with real coefficients) having degree $n$ or less.
\end{notation}
Of course, we can also work with complex polynomials which form a complex vector space. However, for simplicity, we will focus on real polynomials.

It is easy to show that $\dim (P_n[x]) = n + 1$.

\subsection{The interpolation problem}
Suppose we are given $n + 1$ distinct interpolation points $\{x_i\}_{i = 0}^n \subseteq \R$, and $n + 1$ data values $\{f_i\}_{i = 0}^n \subseteq \R$. The objective is to find a $p \in P_n[x]$ such that $p(x_i) = f_i$ for all $i$. In other words, we want to fit a polynomial through the points $(x_i, f_i)$.

We have $n + 1$ coefficients to choose from, and $n + 1$ conditions to satisfy. Given this, in general, there is no guarantee that there is a solution, or that the solution is unique. Our first goal is to show that in the case of polynomial interpolation, the solution exists and is unique.

There are many situations where this may come up. For example, we may have $n + 1$ actual data points, and want to fit a polynomial through the points. Alternatively, we might have a given function $f$, and want to approximate it with a polynomial $p$ such that $p$ and $f$ agree on at least that $n + 1$ points.

\subsection{The Lagrange formula}
It turns out the problem is not too hard. You can probably figure it out yourself if you lock yourself in a room for a few days (or hours). The first solution to this would be via Lagrange cardinal polynomials.
\begin{defi}[Lagrange cardinal polynomials]
  The \emph{Lagrange cardinal polynomials} with respect to the interpolation points $\{x_i\}_{i = 0}^n$ are, for $k = 0, \cdots, n$,
  \[
    \ell_k (x) = \prod_{i = 0, i \not= k}^n \frac{x - x_i}{x_k - x_i}.
  \]
\end{defi}
Note that these polynomials have degree exactly $n$. The significance of these polynomials is that they satisfy
\[
  \ell_k(x_j) = \delta_{jk}.
\]
This is obvious from definition.

With these cardinal polynomials, we can immediately write down a solution to the interpolation problem.
\begin{thm}
  The interpolation problem has exactly one solution.
\end{thm}

\begin{proof}
  We define $p \in P_n[x]$ by
  \[
    p(x) = \sum_{k = 0}^n f_k \ell_k (x).
  \]
  Evaluating at $x_i$ gives
  \[
    p(x_j) = \sum_{k = 0}^n f_k \ell_k(x_j) = \sum_{k = 0}^n f_k \delta_{jk} = f_j.
  \]
  So we get existence.

  For uniqueness, suppose $p, q \in P_n[x]$ are solutions. Then the difference $r = p - q \in P_n[x]$ satisfies $r(x_j) = 0$ for all $j$, ie. it has $n + 1$ roots. However, a non-zero polynomial of degree $n$ can have at most $n$ roots. So in fact $p - q$ is zero, ie. $p = q$.
\end{proof}
So we have solved the problem of polynomials. However, it turns out there is a better way to approach the problem.

\subsection{The Newton formula}
For $k = 0, \cdots, n$, let $p_k \in P_k[x]$ satisfy $p_k(x_i) = f_i$ for $i = 0, \cdots, k$. These are the unique degree-$k$ polynomials that satisfies the first $k$ conditions. Then we can write
\[
  p(x) = p_n(x) = p_0(x) + (p_1(x) - p_0(x)) + \cdots + (p_n(x) - p_{n - 1}(x)).
\]
Hence it suffices to find the differences $p_k - p_{k - 1}$. However, we know that $p_k$ and $p_{k - 1}$ agree on $x_0, \cdots, x_{k - 1}$. So the difference is $0$ at those points, and we have
\[
  p_k(x) - p_{k - 1}(x) = A_k \prod_{i = 0}^{k - 1}(x - x_i),
\]
for some $A_k$ yet to be found out. Then we can write
\[
  p(x) = p_n(x) = A_0 + \sum_{k = 1}^n A_k \prod_{i = 0}^{k - 1} (x - x_i).
\]
This formula has the advantage that it is built up gradually from the interpolation points one-by-one. If we stop the sum at any point, we have obtained the polynomial that interpolates the data for the first $k$ points (for some $k$).

What are the $A_k$'s? For $k = 0$, we know $A_0$ is the unique constant polynomial that interpolates the point at $x_0$, ie. $A_0 = f_0$.

For the others, we note that in the formula for $p_k - p_{k - 1}$, $A_k$ is the leading coefficient of $x^k$. Also, $p_{k - 1}(x)$ has no degree $k$ term. So $A_k$ must be the leading coefficient of $p_k$.

We thus need an efficient algorithm for these \emph{Newton divided differences}. The standard notation for these is
\[
  A_k = f[x_0, \cdots, x_k].
\]
Note in particular that these coefficients depend only on the first $k$ interpolation points.

We will look for a recurrence relation --- a way to express $A_k$ in terms of $A_j$ for $j < k$.

To do so, we first generalize this notion to $f[x_j, \cdots, x_k]$ for $0 \leq j \leq k$. This denotes the leading coefficient of the unique $q \in P_{k - j}[x]$ satisfying $q(x_i) = f_i$ for $i = j, \cdots, k$. Then we get
\begin{thm}[Recurrence relation for Newton divided differences]
  For $0 \leq j < k \leq n$, we have
  \[
    f[x_j, \cdots, x_k] = \frac{f[x_{j + 1}, \cdots, x_k] - f[x_j, \cdots, x_{k - 1}]}{x_k - x_j}.
  \]
\end{thm}

\begin{proof}
  The key to proving this is to relate the interpolating polynomials. Let $q_0, q_1 \in P_{k - j - 1}[x]$ and $q_2 \in P_{k - j}$ satisfy
  \begin{align*}
    q_0(x_i) &= f_i & i &=j, \cdots, k - 1\\
    q_1(x_i) &= f_i & i &=j + 1, \cdots, k\\
    q_2(x_i) &= f_i & i &=j, \cdots, k
  \end{align*}
  We now claim that
  \[
    q_2(x) = \frac{x - x_j}{x_k - x_j} q_1(x) + \frac{x_k - x}{x_k - x_j} q_0(x).
  \]
  Using the properties of $q_0$ and $q_1$, it is easy to show that the right expression satisfies the interpolations of $q_2$. Hence by uniqueness, we know that this is indeed $q_1$. The leading coefficients thus give the result.
\end{proof}
Thus the famous Newton divided difference table can be constructed
\begin{center}
  \begin{tabular}{cccccc}
    \toprule
    $x_i$ & $f_i$ & $f[*, *]$ & $f[*, *, *]$ & $\cdots$ & $f[*, \cdots,*]$\\
    \midrule
    $x_0$ & $f[x_0]$ & $f[x_0, x_1]$ & $f[x_0, x_1, x_2]$ & $\cdots$ & $f[x_0, x_1, \cdots, x_n]$\\
    $x_1$ & $f[x_1]$ & $f[x_1, x_2]$ & $f[x_1, x_2, x_3]$ & $\cdots$\\
    $x_2$ & $f[x_2]$ & $f[x_2, x_3]$ & $f[x_2, x_3, x_4]$ & $\cdots$\\
    $\vdots$ & $\vdots$ & $\vdots$ &\\
    $x_n$ & $f[x_n]$\\
    \bottomrule
  \end{tabular}
\end{center} % beautify
From the first $n$ columns, we can find the $n + 1$th column using the recurrence relation. The values of $A_k$ can then be found at the first row, and this is all we really need. However, to compute the first row, we will need to compute everything in the table.

Here we make two practical points:
\begin{enumerate}
  \item An efficient algorithm ($O(n)$ operations) for evaluating $p(\hat{x})$ at some new value $\hat{x}$ using the above divided difference table is known as \emph{Horner's scheme}:
    \begin{alltt}
      S <- f[\(\mathtt{x\sb{0}}\),..., \(\mathtt{x\sb{n}}\)]
      for k = n - 1,..., 0
          S <- (\(\mathtt{\hat{x}}\) - \(\mathtt{x\sb{k}}\))S + f[\(\mathtt{x\sb{0}}\),..., \(\mathtt{x\sb{k}}\)]
      end
    \end{alltt}
  \item If an extra data point $\{x_{n + 1}, f_{n + 1}\}$ is added, then we only have to compute an extra diagonal $f[x_k, \cdots, x_{n + 1}]$ for $k =n, \cdots, 0$ in the divided difference table to obtain the new coefficient, and the old results can be reused. This requires $O(n)$ operations. This is less straightforward for Lagrange's method.
\end{enumerate}

\subsection{A useful property of divided differences}
In the next couple of sections, we are interested in the error of polynomial interpolation. Suppose the data points come from $f_i = f(x_i)$ for some complicated $f$ we want to approximate. How does the error $e_n(x) = f(x) - p_n(x)$ (where $p_n$ is a degree $n$-interpolation) depend on $n$ and the choice of interpolation points?

Notice that the error is necessarily $0$ at the interpolation points, but this does not necessarily mean that the errors elsewhere will be small.

We first start with a lemma that is purely a calculus result:
\begin{lemma}
  Let $g \in C^m[a, b]$ have a continuous $m$th derivative. Suppose $g$ is zero at $m + \ell$ distinct points. Then $g^{(m)}$ has at least $\ell$ distinct zeros in $[a, b]$.
\end{lemma}

\begin{proof}
  This is a repeated application of Rolle's theorem. We know that between every two zeros of $g$, there is at least one zero of $g' \in C^{m - 1}[a, b]$. So by differentiating once, we have lost at most $1$ zeros. So after differentiating $m$ times, $g^{(m)}$ has lost at most $m$ zeros. So it still has at least $\ell$ zeros.
\end{proof}

\begin{thm}
  If $\{x_i\}_{i = 0}^n \in [a, b]$ and $f \in C^n[a, b]$. Then there exists some $\xi \in (a, b)$ such that
  \[
    f[x_0, \cdots, x_n] = \frac{1}{n!} f^{(n)}(\xi).
  \]
\end{thm}

\begin{proof}
  Consider $e = f - p_n \in C^n[a, b]$. This has at least $n + 1$ distinct zeros in $[a, b]$. So by the lemma, $e^{(n)} = f^{(n)} - p_n^{(n)}$ must vanish at some $\xi \in (a, b)$. But then $p_n^{(n)} = n! f[x_0, \cdots, x_n]$ constantly. So the result follows.
\end{proof}
With this result, we can get error bounds rather easily.

\subsection{Error bounds for polynomial interpolation}
It turns out the error $e = f - p_n$ is ``like the next term in the Newton's formula''. This vague sentence is made precise in the following theorem:
\begin{thm}
  Assume $\{x_i\}_{i = 0}^n \subseteq [a, b]$ and $f \in C[a, b]$. Let $\bar{x} \in [a, b]$ be a non-interpolation point. Then
  \[
    e_n(\bar{x}) = f[x_0, x_1, \cdots, x_n, \bar{x}] \omega(\bar{x}),
  \]
  where
  \[
    \omega(x) = \prod_{i = 0}^n (x - x_i).
  \]
\end{thm}
Note that we forbid the case where $\bar{x}$ is an interpolation point, since it is not clear what the expression $f[x_0, x_1, \cdots, x_n, \bar{x}]$ means. However, if $\bar{x}$ is an interpolation point, then both $e_n(\bar x)$ and $\omega(\bar{x})$ are zero, so the statement is trivial.

\begin{proof}
  We think of $\bar{x} = x_{n + 1}$ as a new interpolation point so that
  \[
    p_{n + 1}(x) - p_n(x) = f[x_0, \cdots, x_n, \bar{x}] \omega(x)
  \]
  for all $x \in R$. In particular, putting $x = \bar{x}$, we have $p_{n + 1}(\bar{x}) = f(\bar{x})$, and we get the result.
\end{proof}

Combining the two results, we find
\begin{thm}
  If in addition $f \in C^{n + 1}[a, b]$, then for each $x \in [a, b]$, we can find $\xi_x \in (a, b)$ such that
  \[
    e_n(x) = \frac{1}{(n + 1)!} f^{(n + 1)}(\xi_x) \omega(x)
  \]
\end{thm}

\begin{proof}
  The statement is trivial if $x$ is an interpolation point --- pick arbitrary $\xi_x$, and both sides are zero. Otherwise, this follows directly from the last two theorems.
\end{proof}

This is an exact result, which is not too useful, since there is no easy constructive way of finding what $\xi_x$ should be. Instead, we usually go for a bound. We introduce the max norm
\[
  \|g\|_{\infty} = \max_{t \in [a, b]} |g(t)|.
\]
This gives the more useful bound
\begin{prop}
  For all $x \in [a, b]$, we have
  \[
    |f(x) - p_n(x)| \leq \frac{1}{(n + 1)!} \|f^{(n + 1)}\|_{\infty} |\omega(x)|
  \]
\end{prop}

We are now going to see what happens when we vary the interpolation points. The error bound only depends on the interpolation points through $\omega(x)$. So can we minimize $\omega(x)$ in some sense by picking some clever interpolation points $\Delta = \{x_i\}_{i = 0}^n$? Here we will have $n$ fixed. So instead, we put $\Delta$ as the subscript. We can write
\[
  \|f - p_{\Delta}\|_{\infty} \leq \frac{1}{(n + 1)!} \|f^{(n + 1)}\|_{\infty} \|\omega_{\Delta}\|_{\infty}.
\]
So the objective is to find a $\Delta$ that minimizes $\|\omega_{\Delta}\|_{\infty}$.

For the moment, we focus on the special case where the interval is $[-1, 1]$. Then later we can get the general solution by an easy change of variable. The solution involves the use of Chebyshev polynomials:
\begin{defi}[Chebyshev polynomial]
  The \emph{Chebyshev polynomial} of degree $n$ on $[-1, 1]$ is defined by
  \[
    T_n(x) = \cos(n \theta),
  \]
  where $x = \cos \theta$ with $\theta\in [0, \pi]$.
\end{defi}
So given an $x$, we find the unique $\theta$ that satisfies $x = \cos \theta$, and then find $\cos (n \theta)$. This is in fact a polynomial in disguise, since from trigonometric identities, we know $\cos (n\theta)$ can be expanded as a polynomial in $\cos \theta$ up to degree $n$.

Two key properties of $T_n$ on $[-1, 1]$ are
\begin{enumerate}
  \item The maximum absolute value is obtained at
    \[
      X_k = \cos\left(\frac{\pi k}{n}\right)
    \]
    for $k = 0, \cdots, n$ with
    \[
      T_n(X_k) = (-1)^k.
    \]
  \item This has $n$ distinct zeros at
    \[
      x_k = \cos\left(\frac{2k - 1}{2n}\pi\right).
    \]
    for $k = 1, \cdots, n$.
\end{enumerate}
Notice there is an intentional clash between the use of $x_k$ as the zeros and $x_k$ as the interpolation points --- we will show these are indeed the optimal interpolation points.
\begin{center}
  \begin{tikzpicture}[scale=2]
    \draw [->] (-1.5, 0) -- (1.5, 0) node [right] {$x$};
    \draw [->] (0, -1.5) -- (0, 1.5) node [above] {$T_4(x)$};

    \draw [mblue,domain=0:180, samples=40] plot [smooth] ({cos(\x)}, {cos(4*\x)});
    \draw [dashed] (-1, -1) rectangle (1, 1);
    \node at (-1, 0) [below] {$-1$};
    \node at (1, 0) [below] {$1$};
    \node at (0, 1) [anchor = south west] {$1$};
    \node at (0, -1) [left] {$-1$};
  \end{tikzpicture}
\end{center}
We first prove a recurrence relation for the Chebyshev polynomials:
\begin{lemma}[3-term recurrence relation]
  The Chebyshev polynomials satisfy the recurrence relations
  \[
    T_{n + 1}(x) = 2x T_n(x) - T_{n - 1}(x)
  \]
  with initial conditions
  \[
    T_0(x) = 1,\quad T_1(x) = x.
  \]
\end{lemma}
\begin{proof}
  \[
    \cos((n + 1) \theta) + \cos((n - 1)\theta) = 2\cos \theta \cos(n\theta).
  \]
\end{proof}
In particular, we know the leading coefficient of $T_n$ is $2^{n - 1}$ (for $n \geq 1$).

\begin{thm}[Minimal property for $n \geq 1$]
  On $[-1, 1]$, among all polynomials $p \in P_n[x]$ with leading coefficient $1$, $\frac{1}{2^{n - 1}} \|T_n\|$ minimizes $\|p\|_{\infty}$. Thus, the minimum value is $\frac{1}{2^{n - 1}}$.
\end{thm}

\begin{proof}
  We proceed by contradiction. Suppose there is a polynomial $q_n \in P_n$ with leading coefficient $1$ such that $\|q_n\|_{\infty} < \frac{1}{2^{n - 1}}$. Define a new polynomial
  \[
    r = \frac{1}{2^{n - 1}}T_n - q_n.
  \]
  This is, by assumption, non-zero.

  Since both the polynomials have leading coefficient $1$, the difference must have degree at most $n - 1$, ie. $r \in P_{n - 1}[x]$. Since $\frac{1}{2^{n - 1}}T_n(X_k) = \pm \frac{1}{2^{n - 1}}$, and $|q_n(X_n)| < \frac{1}{2^{n - 1}}$ by assumption, $r$ alternates in sign between these $n + 1$ points. But then by the intermediate value theorem, $r$ has to have at least $n$ zeros. This is a contradiction, since $r$ has degree $n - 1$, and cannot be zero.
\end{proof}

\begin{cor}
  Consider
  \[
    w_\Delta = \prod_{i = 0}^n (x - x_i) \in P_{n + 1}[x]
  \]
  for any distinct points $\Delta = \{x_i\}_{i = 0}^n \subseteq [-1, 1]$. Then
  \[
    \min_{\Delta} \|\omega_{\Delta}\|_{\infty} = \frac{1}{2^n}.
  \]
  This minimum is achieved by picking the interpolation points to be the zeros of $T_{n + 1}$, namely
  \[
    x_k = \cos\left(\frac{2k + 1}{2n + 2} \pi\right), \quad k = 0, \cdots, n.
  \]
\end{cor}

\begin{thm}
  For $f \in C^{n + 1}[-1, 1]$, the Chebyshev choice of interpolation points gives
  \[
    \|f - p_n\|_{\infty} \leq \frac{1}{2^n} \frac{1}{(n + 1)!} \|f^{(n + 1)}\|_{\infty}.
  \]
\end{thm}
Suppose $f$ has as many continuous derivatives as we want. Then as we increase $n$, what happens to the error bounds? The coefficients involve dividing by an exponential \emph{and} a factorial. Hence as long as the higher derivatives of $f$ don't blow up too badly, in general, the error will tend to zero as $n \to \infty$.

The last two results can be easily generalized to arbitrary intervals $[a, b]$, and this is left as an exercise for the reader.

\section{Orthogonal polynomials}
We are now going to look at general orthogonal polynomials, where the Chebyshev polynomials is a famous set of example.

Of course, the property of being orthogonal depends on our choice on the scalar product.

\subsection{Scalar product}
The scalar products we are interested in would be generalization of the usual scalar product on Euclidean space,
\[
  \bra \mathbf{x}, \mathbf{y}\ket = \sum_{i = 1}^n x_i y_i.
\]
We want to generalize this to vector spaces of functions and polynomials. We will not provide a formal definition of vector spaces and scalar products on an abstract vector space. Instead, we will just provide some examples of commonly used ones.
\begin{eg}\leavevmode
  \begin{enumerate}
    \item Let $V = C^s[a, b]$, where $[a, b]$ is a finite interval and $s \geq 0$. Pick a weight function $w(x) \in C(a, b)$ such that $w(x) > 0$ for all $x \in (a, b)$, and $w$ is integrable over $[a, b]$. In particular, we allow $w$ to vanish at the end points, or blow up mildly such that it is still integrable.

      We then define the inner product to be
      \[
        \bra f, g\ket = \int_a^b w(x) f(x) d(x)\;\d x.
      \]
    \item We can allow $[a, b]$ to be infinite, eg. $[0, \infty)$ or even $(-\infty, \infty)$, but we have to be more careful. We first define
      \[
        \bra f, g\ket = \int_a^b w(x) f(x) g(x) \;\d x
      \]
      as before, but we now need more conditions. We require that $\int_a^b w(x) x^n\;\d x$ to exist for all $n \geq 0$, since we want to allow polynomials in our vector space. For example, $w(x) = e^{-x}$ on $[0, \infty)$, works, or $w(x) = e^{-x^2}$ on $(-\infty, \infty)$. These are scalar products for $P_n[x]$ for $n \geq 0$, but we cannot extend this definition to all smooth functions since they might blow up too fast at infinity. We will not go into the technical details, since we are only interested in polynomials, and knowing it works for polynomials suffices.
    \item We can also have a discrete inner product, defined by
      \[
        \bra f, g\ket = \sum_{j = 1}^m w_j f(\xi_j) g(\xi_j)
      \]
      with $\{\xi_j\}_{j = 1}^m$ distinct points and $\{w_j\}_{j = 1}^m > 0$. Now we have to restrict ourselves a lot. This is a scalar product for $V = P_{m - 1}[x]$, but not for higher degrees, since a scalar product should satisfy $\bra f, f \ket > 0$ for $f \not= 0$. In particular, we cannot extend this to all smooth functions.
  \end{enumerate}
\end{eg}
With an inner product, we can define orthogonality.
\begin{defi}[Orthogonalilty]
  Given a vector space $V$ and an inner product $\bra \ph, \ph\ket$, two vectors $f, g \in V$ are \emph{orthogonal} if $\bra f, g\ket = 0$.
\end{defi}

\subsection{Orthogonal polynomials}
\begin{defi}[Orthogonal polynomial]
  Given a vector space $V$ of polynomials and inner product $\bra \ph, \ph\ket$, we say $p_n \in P_n[x]$ is the \emph{$n$th orthogonal polynomial} if
  \[
    \bra p_n, q\ket = 0\text{ for all }q \in P_{n - 1}[x].
  \]
  In particular, $\bra p_n, p_m\ket = 0$ for $n \not= m$.
\end{defi}

We said \emph{the} orthogonal polynomial, but we need to make sure such a polynomial has to be unique. It is clearly not unique, since if $p_n$ satisfies these relations, then so does $\lambda p_n$ for all $\lambda \not= 0$. For uniqueness, we need to impose some scaling. We usually do so by requiring the leading polynomial to be $1$, ie. it is monic.

\begin{defi}[Monic polynomial]
  A polynomial $p \in P_n[x]$ is \emph{monic} if the coefficient of $x^n$ is $1$.
\end{defi}
However, most famous traditional polynomials are not monic. They have a different scaling imposed. Still, picking a different scaling will not affect the uniqueness result.

We will stick to requiring them to be monic since this is useful for proving things.

\begin{thm}
  Given a vector space $V$ of functions and an inner product $\bra \ph, \ph \ket$, there exists a unique monic orthogonal polynomial for each degree $n \geq 0$. In addition, $\{p_k\}_{k = 0}^n$ form a basis for $P_n[x]$.
\end{thm}

\begin{proof}
  This is a big induction proof over both parts of the theorem. We induct over $n$. For the base case, we pick $p_0(x) = 1$, which is the only degree-zero monic polynomial.

  Now suppose we already have $\{p_n\}_{k = 0}^n$ satisfying the induction hypothesis.

  Now pick any monic $q_{n + 1} \in P_{n + 1}[x]$, eg. $x^{n + 1}$. We now construct $p_{n + 1}$ from $q_{n + 1}$ by the Gram-Schmidt process. We define
  \[
    p_{n + 1} = q_{n + 1} - \sum_{k = 0}^n \frac{\bra q_{n + 1}, p_k\ket}{\bra p_k, p_k\ket} p_k.
  \]
  This is again monic since $q_{n + 1}$ is, and we have
  \[
    \bra p_{n + 1}, p_m \ket = 0
  \]
  for all $m \leq n$, and hence $\bra p_{n + 1}, p\ket = 0$ for all $p \in P_n[x] = \bra p_0, \cdots,p_n\ket$.

  To obtain uniqueness, assume both $p_{n + 1}, \hat{p}_{n + 1} \in P_{n + 1}[x]$ are both monic orthogonal polynomials. Then $r = p_{n + 1} - \hat{p}_{n + 1} \in P_n[x]$. So
  \[
    \bra r, r\ket = \bra r, p_{n + 1} - \hat{p}_{n + 1}\ket = \bra r, p_{n + 1}\ket - \bra r, \hat{p}_{n + 1}\ket = 0 - 0 = 0.
  \]
  So $r = 0$. So $p_{n + 1} = \hat{p}_{n - 1}$.

  Finally, we have to show that $p_0, \cdots, p_{n + 1}$ form a basis for $P_{n + 1}[x]$. Now note that every $p \in P_{n + 1}[x]$ can be written uniquely as
  \[
    p = cp_{n + 1} + q,
  \]
  where $q \in P_n[x]$. But $\{p_k\}_{k = 0}^n$ is a basis for $P_n[x]$. So $q$ can be uniquely decomposed as a linear combination of $p_0, \cdots, p_n$.

  Alternatively, this follows from the fact that any set of orthogonal vectors must be linearly independent, and since there are $n + 2$ of these vectors and $P_{n + 1}[x]$ has dimension $n + 2$, they must be a basis.
\end{proof}

In practice, following the proof naively is not the best way of producing the new $p_{n + 1}$. Instead, we can reduce a lot of our work by making a clever choice of $q_{n + 1}$.

\subsection{Three-term recurrence relation}
Recall that for the Chebyshev polynomials, we obtained a three-term recurrence relation for them. It turns out these recurrence relations exist in general.

We start by picking $q_{n + 1} = xp_n$ in the previous proof. We now use the fact that
\[
  \bra xf, g\ket = \bra f, xg\ket.
\]
This is not necessarily true for arbitrary inner products, but for most sensible inner products we will meet in this course, this is true. In particular, it is clearly true for inner products of the form
\[
  \bra f, g\ket = \int w(x) f(x) g(x)\;\d x.
\]
Assuming this, we obtain the following theorem.
\begin{thm}
  Monic orthogonal polynomials are generated by
  \[
    p_{k + 1}(x) = (x - \alpha_k)p_k(x) - \beta_k p_{k - 1}(x)
  \]
  with initial conditions
  \[
    p_0 = 1,\quad p_1(x) = (x - \alpha_0) p_0,
  \]
  where
  \[
    \alpha_k = \frac{\bra x p_k, p_k\ket}{\bra p_k, p_k\ket},\quad \beta_k = \frac{\bra p_k, p_k\ket}{\bra p_{k - 1}, p_{k - 1}\ket}.
  \]
\end{thm}

\begin{proof}
  By inspection, the $p_1$ given is monic and satisfies
  \[
    \bra p_1, p_0\ket = 0.
  \]
  Using $q_{n + 1} = x p_n$ in the Gram-Schmidt process gives
  \begin{align*}
    p_{n + 1} &= xp_n - \sum_{k = 0}^n \frac{\bra x p_n, p_k\ket}{\bra p_k, p_k\ket} p_k\\
    \intertext{We have $\bra xp_n, p_k\ket = \bra p_n, xp_k\ket$, and vanishes whenever $x p_k$ has degree less than $n$. So we are left with}
    &= (x - \alpha_n) p_n - \frac{\bra p_n, xp_{n - 1}\ket}{\bra p_{n - 1}, p_{n - 1}\ket} p_{n - 1}.
  \end{align*}
  Now we notice that $xp_{n - 1}$ is a monic polynomial of degree $n$ so we can write this as $x p_{n - 1} = p_n + q$. Thus
  \[
    \bra p_n, xp_{n - 1}\ket = \bra p_n, p_n + q\ket = \bra p_n, p_n\ket.
  \]
  Hence the coefficient of $p_{n - 1}$ is indeed the $\beta$ we defined.
\end{proof}

\subsection{Examples}
The four famous examples are the Legendre polynomials, Chebyshev polynomials, Laguerre polynomials and Hermite polynomials. We will not waste time looking at them. Instead, we will see how the Chebyshev polynomials fit into this framework.

Chebyshev is based on the scalar product defined by
\[
  \bra f, g\ket = \int_{-1}^1 \frac{1}{\sqrt{1 - x^2}} f(x) g(x)\;\d x.
\]
Note that the weight function blows up mildly at the end.

This links up with
\[
  T_n (x) = \cos(n\theta)
\]
for $x = \cos \theta$ via the usual trigonometric substitution. We have
\begin{align*}
  \bra T_n, T_m \ket &= \int_0^\pi \frac{1}{\sqrt{1 - \cos^2 \theta}} \cos(n\theta) \cos (m\theta) \sin \theta \;\d \theta\\
  &= \int_0^\pi \cos(n\theta) \cos (m\theta)\;\d \theta\\
  &= 0\text{ if }m\not= n.
\end{align*}
\subsection{Least-squares polynomial approximation}
This is an alternative to polynomial interpolation. Instead of trying to make a polynomial agree with $f$ at certain points and hoping it is a good approximation elsewhere, the idea is to choose a polynomial $p \in P_n[x]$ to minimize the error
\[
  \bra f - p, f - p\ket = \int_a^b w(x) [f(x) - p(x)]^2 \;\d x.
\]
We can also use alternative inner products such as
\[
  \bra f - p, f - p\ket = \sum_{j = 1}^m w_j [f(\xi_i) - p(\xi_i)]^2.
\]
Unlike polynomial interpolation, there is no guarantee that the approximation agrees with the function anywhere. Unlike polynomial interpolation, there is some guarantee that the total error is small (or as small as we can get, by definition). In particular, if $f$ is continuous, then the Weierstrass approximation theorem tells us the total error must eventually vanish.

The solution is to use orthogonal polynomials with respect to the corresponding inner products
\[
  \bra f, g\ket = \int_a^b w(x) f(x) g(x)\;\d x
\]
or
\[
  \bra f, g\ket = \sum_{j = 1}^m w_j f(\xi_j) g(\xi_j),
\]
in order to minimize
\[
  \|f - p\|^2 = \bra f - p, f - p\ket.
\]
\begin{thm}
  If $\{p_n\}_{k = 0}^n$ are orthogonal polynomials with respect to $\bra \ph, \ph \ket$, then the choice of $c_k$ such that
  \[
    p = \sum_{k = 0}^n c_k p_k
  \]
  minimizes $\|f - p\|^2$ is given by
  \[
    c_k = \frac{\bra f, p_k\ket}{\|p_k\|^2},
  \]
  and the formula for the error is
  \[
    \|f - p\|^2 = \|f\|^2 - \sum_{k = 0}^n \frac{\bra f, p_k\ket^2}{\|p_k\|^2}.
  \]
\end{thm}
Note that the solution decouples, in the sense that $c_k$ depends only on $f$ and $p_k$. If we want to take one more term, we just need to compute an extra term, and not redo our previous work.

Also, we notice that the formula for the error is a positive term $\|f\|^2$ subtracting a lot of squares. As we increase $n$, we subtract more squares, and the error decreases. If we are lucky, the error tends to $0$ as we take $n \to \infty$. Even though we might not know how many terms we need in order to get the error to be sufficiently small, we can just keep adding terms until the computed error small enough (which is something we have to do anyway even if we know what $n$ to take).

\begin{proof}
  We consider a general polynomial
  \[
    p = \sum_{k = 0}^n c_k p_k.
  \]
  We substitute this in to obtain
  \[
    \bra f - p, f - p\ket = \bra f, f\ket - 2 \sum_{k = 0}^n c_k \bra f, p_k\ket + \sum_{k = 0}^n c_k^2 \|p_k\|^2.
  \]
  Note that there are no cross terms between the different coefficients. We minimize this quadratic by setting the partial derivatives to zero:
  \[
    0 = \frac{\partial}{\partial c_k} \bra f - p, f - p\ket = -2 \bra f, p_k\ket + 2c_k \|p_k\|^2.
  \]
  To check this is indeed a minimum, note that the Hessian matrix is simply $2I$, which is positive definite. So this is really a minimum. So we get the formula for the $c_k$'s as claimed, and putting the formula for $c_k$ gives the error formula.
\end{proof}

Note that our constructed $p \in P_n[x]$ has a nice property: for $k \leq n$, we have
\[
  \bra f - p, p_k\ket = \bra f, p_k\ket - \bra p, p_k\ket = \bra f, p_k\ket - \frac{\bra f, p_k\ket}{\|p_k\|^2} \bra p_k, p_k\ket = 0.
\]
Thus for all $q \in P_n[x]$, we have
\[
  \bra f - p, q\ket = 0.
\]
In particular, this is true when $q = p$, and tells us $\bra f, p\ket = \bra p, p\ket$. Using this to expand $\bra f - p, f - p\ket$ gives
\[
  \|f - p\|^2 + \|p\|^2 = \|f\|^2,
\]
which is just a glorified Pythagoras theorem.
\section{Approximation of linear functionals}
\subsection{Linear functionals}
We start by explaining what we mean ``functional''.
\begin{defi}[Linear functional]
  A \emph{linear functional} is a linear mapping $L: V \to \R$, where $V$ is a real vector space of functions.
\end{defi}
In generally, a linear functional is a linear mapping from a vector space to its underlying field of scalars, but for the purposes of this course, we will restrict to this special case.

\begin{eg}\leavevmode
  \begin{enumerate}
    \item We can choose some fixed $\xi \in \R$, and define a linear functional by
      \[
        L(f) = f(\xi).
      \]
    \item Alternatively, for fixed $\eta \in \R$ we can define our functional by
      \[
        L(f) = f'(\eta).
      \]
      In this case, we need to pick a vector space in which this makes sense, eg. the space of continuously differentiable functions.
    \item We can define
      \[
        L(f) = \int_a^b f(x)\;\d x.
      \]
      The set of continuous (or even just integrable) functions defined on $[a, b]$ will be a sensible domain for this linear functional.
    \item Any linear combination of these linear functions are also linear functionals. For example, we can pick some fixed $\alpha, \beta \in \R$, and define
      \[
        L(f) = f(\beta) - f(\alpha) - \frac{\beta - \alpha}{2} [f'(\beta) + f'(\alpha)]. % should be plus
      \]
  \end{enumerate}
\end{eg}

We will attempt to construct approximations to more complicated linear functionals (usually integrals, possibly derivatives point values) in terms of simpler linear functionals (usually point values of $f$ itself).

For example, we might produce an approximation of the form
\[
  L(f) \approx \sum_{i = 0}^N a_i f(x_i),
\]
where $V = C^p[a, b]$, $p \geq 0$, and $\{x_i\}_{i = 0}^N \subseteq [a, b]$ are distinct points.

How can we choose the coefficients $a_i$ and the points $x_i$ so that our approximation is ``good''?

For a start, we let $ \{x_i\}_{i = 0}^N \subseteq [a, b]$ be arbitrary points. Then $\{a_i\}_{i = 0}^N$ can be derived from interpolation theory. We first approximate $f$ by polynomials, and then attempt to find $L(p)$ exactly for polynomials. In particular, we have
\[
  L(f) \approx L\left(\sum_{i = 0}^N f(x_i) \ell_i(x)\right) = \sum_{i = 0}^N L(\ell_i) f(x_i).
\]
Similar to polynomial interpolation, this formula is exact for $f \in P_N[x]$.

Suppose we can freely choose $\{a_i\}_{i = 0}^N$ \emph{and} $\{x_i\}_{i = 0}^N$. Then since we now have $2n + 2$ free parameters, we might expect to find an approximation that is exact for $f \in P_{2N + 1}[x]$. This is not always possible, but there are cases when we can. The most famous example is Gaussian quadrature.

\subsection{Gaussian quadrature}
Note that traditionally, we have a different set of notations used for Gaussian quadrature. So the notation used here will be inconsistent with what we are doing elsewhere in the course.

Let
\[
  \bra f, g\ket = \int_a^b w(x) f(x)g(x)\;\d x
\]
be a scalar product for $P_\nu[x]$. Then we can find \emph{weights}, written $\{b_n\}_{k = 1}^\nu$, and \emph{nodes}, written $\{c_k\}_{k = 1}^\nu \subseteq [a, b]$, such that the approximation
\[
  \int_a^b w(x) f(x)\;\d x \approx \sum_{k = 1}^{\nu} b_k f(c_k)
\]
is exact for $f \in P_{2\nu - 1}[x]$. The nodes $\{c_k\}_{k = 1}^{\nu}$ will turn out to be the zeros of the orthogonal polynomial $p_\nu$ with respect to the scalar product. The aim of this section is to work this thing out.

We start by showing that this is the best we can achieve.
\begin{prop}
  There is no choice of $\nu$ weights and nodes such that the approximation of $\int_a^b w(x) f(x)\;\d x$ is exact for all $f \in P_{2\nu}[x]$.
\end{prop}

\begin{proof}
  Define
  \[
    q(x) = \prod_{k = 1}^{\nu} (x - c_k) \in P_{\nu}[x].
  \]
  Then we know
  \[
    \int_a^b w(x) q^2(x)\;\d x > 0,
  \]
  since $q^2$ is always non-negative and has finitely many zeros. However,
  \[
    \sum_{k = 1}^\nu b_k q^2(c_n) = 0.
  \]
  So this cannot be exact for $q^2$.
\end{proof}

We first revisit our previous naive method, and formulate it as a theorem.
\begin{thm}[Ordinary quadrature]
  For any distinct $\{c_k\}_{k = 1}^\nu \subseteq [a, b]$, let $\{\ell_k\}_{k = 1}^\nu$ be the Lagrange cardinal polynomials with respect to $\{c_k\}_{k = 1}^\nu$. Then choosing
  \[
    b_k = \int_a^b w(x) \ell_k(x) \;\d x,
  \]
  we achieve exactness for $f \in P_{\nu - 1}[x]$.

  We call this method ordinary quadrature.
\end{thm}
This simple idea is how we generate many classical numerical integration techniques, such as the trapezoidal rule. But those are quite inaccurate. A clever choice of $\{c_k\}$ does much better --- take them to be the zeros of the orthogonal polynomials. However, to do this, we must make sure the roots indeed lie in $[a, b]$. This is what we will prove now --- given any inner product, the roots of the orthogonal polynomials must lie in $[a, b]$.

\begin{thm}
  For $\nu \geq 1$, the zeros of the orthogonal polynomial $p_\nu$ are real, distinct and lie in $(a, b)$.
\end{thm}
We have in fact proved this for a particular case in IB Methods, and the same argument applies.

\begin{proof}
  First we show there is at least one root. Notice that $p_0 = 1$. Thus for $\nu \geq 1$, by orthogonality, we know
  \[
    \int_a^b w(x) p_\nu(x) p_1(x)\;\d x = \int_a^b p_\nu(x)\;\d x = 0.
  \]
  So there is at least one sign change in $(a, b)$. We have already got the result we need for $\nu = 1$, since we only need one zero in $(a, b)$.

  Now for $\nu > 1$, suppose $\{\xi_j\}_{j = 1}^m$ are the places where the sign of $p_\nu$ changes in $(a, b)$ (which is a subset of the roots of $p_\nu$). We define
  \[
    q(x) = \prod_{j = 1}^m (x - \xi_j) \in P_m[x].
  \]
  Since this changes sign at the same place as $p_\nu$, we know $q p_\nu$ maintains the same sign in $(a, b)$. Now if we had $m < \nu$, then orthogonality gives
  \[
    \bra q, p_\nu\ket = \int_a^b w(x)q(x) p_\nu(x)\;\d x = 0,
  \]
  which is impossible, since $qp_\nu$ does not change sign. Hence we must have $m = \nu$.
\end{proof}

\begin{thm}
  In the ordinary quadrature, if we pick $\{c_k\}_{k = 1}^\nu$ to be the roots of $p_\nu(x)$, then get we exactness for $f \in P_{2\nu - 1}[x]$. In addition, $\{b_n\}_{k = 1}^\nu$ are all positive.
\end{thm}

\begin{proof}
  Let $f \in P_{2 \nu - 1}[x]$. Then by polynomial division, we get
  \[
    f = qp_\nu + r,
  \]
  where $q, r$ are polynomials of degree at most $\nu - 1$. We apply orthogonality to get
  \[
    \int_a^b w(x) f(x)\;\d x = \int_a^b w(x) (q(x) p_\nu(x) + r(x)) \;\d x= \int_a^b w(x) r(x)\;\d x.
  \]
  Also, since each $c_k$ is a root of $p_\nu$, we get
  \[
    \sum_{k = 1}^\nu b_k f(c_k) = \sum_{k = 1}^\nu b_k (q(c_k) p_\nu(c_k) + r(c_k)) = \sum_{k = 1}^\nu b_k r(c_k).
  \]
  But $r$ has degree at most $\nu - 1$, and this formula is exact for polynomials in $P_{\nu - 1}[x]$. Hence we know
  \[
    \int_a^b w(x) f(x)\;\d x = \int_a^b w(x) r(x)\;\d x = \sum_{k = 1}^\nu b_k r(c_k) = \sum_{k = 1}^\nu b_k f(c_k).
  \]
  To show the weights are positive, we simply pick as special $f$. Consider $f \in \{\ell_k^2\}_{k = 1}^\nu \subseteq P_{2\nu - 2}[x]$, for $\ell_k$ the Lagrange cardinal polynomials for $\{c_k\}_{k = 1}^\nu$. Since the quadrature is exact for these, we get
  \[
    0 < \int_a^b w(x)\ell_k^2(x)\;\d x = \sum_{j = 1}^\nu b_j \ell_k^2(c_j) = \sum_{j = 1}^\nu b_j \delta_{jk} = b_k.
  \]
  Since this is true for all $k = 1, \cdots, \nu$, we get the desired result.
\end{proof}

\begin{eg}
  Any of the famous four (Legendre, Chebyshev, Laguerre and Hermite) orthogonal polynomials generate corresponding famous quadrature rules.
\end{eg}

\section{Expressing errors in terms of derivatives}
As before, we approximate a linear functional $L$ by
\[
  L(f) \approx \sum_{i = 0}^n a_i L_i(f),
\]
where $L_i$ are some simpler linear functionals, and suppose this is exact for $f \in P_k[x]$ for some $k \geq 0$.

Hence we know the error
\[
  e_L(f) = L(f) - \sum_{i = 0}^n a_i L_i(f) = 0
\]
whenever $f \in P_k[x]$. We say the error \emph{annihilates} for polynomials of degree less than $k$.

How can we use this property to generate formulae for the error and error bounds? We first start with a rather simple example.
\begin{eg}
  Let $L(f) = f(\beta)$. We decide to be silly and approximate $L(f)$ by
  \[
    L(f) \approx f(\alpha) + \frac{\beta - \alpha}{2} (f'(\beta) + f'(\alpha)),
  \]
  where $\alpha \not= \beta$. This is clearly much easier to evaluate. One can check that
  \[
    e_L(f) = f(\beta) - f(\alpha) - \frac{\beta - \alpha}{2} (f'(\beta) + f'(\alpha)),
  \]
  and this vanishes for $f \in P_2[x]$.
\end{eg}
How can we get error formula? We can't just use the fact that it annihilates polynomials of degree $k$. We need to introduce something beyond this --- the $k + 1$th derivative. We now assume $f \in C^{k + 1}[a, b]$.

Note that so far, everything we've done works if the interval is infinite, as long as the weight function vanishes sufficiently quickly as we go far away. However, for this little bit, we will need to require $[a, b]$ to be finite.

Now, we seek an exact error formula in terms of $f^{(k + 1)}$, and bounds of the form
\[
  |e_L(f)| \leq c_L \|f^{(k + 1)}\|_{\infty}
\]
for some constant $c_L$. Here we need finiteness of the interval to ensure $\|f^{(k + 1)}\|_{\infty}$ exists. Moreover, we want to make $c_L$ as small as possible. We don't want to give a constant of $10$ million, while in reality we can just use $2$.

\begin{defi}[Sharp error bound]
  The constant $c_L$ is said to be \emph{sharp} if for any $\varepsilon > 0$, there is some $f_{\varepsilon} \in C^{k + 1}[a, b]$ such that
  \[
    |e_L(f)| \geq (c_L - \varepsilon)\|f^{(k + 1)}_\varepsilon\|_{\infty}.
  \]
\end{defi}

This makes it precise what we mean by $c_L$ ``cannot be better''. This doesn't say anything about whether $c_L$ can actually be achieved. This depends on the particular form of the question.

To proceed, we need Taylor's theorem with the integral remainder, ie.
\[
  f(x) = f(a) + (x - a) f'(a) + \cdots + \frac{(x - a)^k}{k!} f^{(k)}(a) + \frac{1}{k!}\int_a^x (x - \theta)^k f^{(k + 1)}(\theta)\;\d \theta.
\]
This is not really good, since there is an $x$ in the upper limit of the integral. Instead, we write the integral as
\[
  \int_a^b (x - \theta)^k_{+} f^{(k + 1)}(\theta)\;\d \theta,
\]
where we define $(x - \theta)^k_+$ is a new function defined by
\[
  (x - \theta)^k_+ =
  \begin{cases}
    (x - \theta)^k &x \geq \theta\\
    0 & x < \theta.
  \end{cases}
\]
Then if $\lambda$ is a linear functional that annihilates $P_k[x]$, then we have
\[
  \lambda(f) = \lambda\left(\frac{1}{k!}\int_a^b (x - \theta)^k_+ f^{(k + 1)}(\theta)\;\d \theta\right)
\]
for all $f \in C^{k + 1}[a, b]$.

For \emph{our} linear functionals, we can simplify by taking the $\lambda$ inside the integral sign and obtain
\[
  \lambda(f) = \frac{1}{k!} \int_a^b \lambda((x - \theta)_+^k) f^{(k + 1)}(\theta)\;\d \theta,
\]
noting that $\lambda$ acts on $(x - \theta)_{+}^k \in C^{k - 1}[a, b]$ as a function of $x$, and think of $\theta$ as being held constant.

Of course, pure mathematicians will come up with linear functionals for which we cannot move the $\lambda$ inside, but for our linear functionals (point values, derivative point values, integrals etc.), this is valid, as we can verify directly.

Hence we arrive at
\begin{thm}[Peano kernel theorem]
  If $\lambda$ annihilates polynomials of degree $k$ or less, then
  \[
    \lambda(f) = \frac{1}{k!} \int_a^b K(\theta) f^{(k + 1)}(\theta) \;\d \theta
  \]
  for all $f \in C^{k + 1}[a, b]$, where
\end{thm}

\begin{defi}[Peano kernel]
  The \emph{Peano kernel} is
  \[
    K(\theta) = \lambda ((x - \theta)_+^k).
  \]
\end{defi}
The important thing is that the kernel $K$ is independent of $f$. Then we get the bounds:
\[
  |\lambda(f)| \leq \frac{1}{k!}
  \begin{dcases}
    \int_a^b |K(\theta)|\;\d \theta \|f^{(k + 1)}\|_\infty\\
    \left(\int_a^b |K(\theta)|^2 \;\d \theta\right)^{\frac{1}{2}}\|f^{(k + 1)}\|_2\\
    \|K(\theta)\|_\infty \|f^{(k + 1)}\|_1
  \end{dcases}.
\]
Hence we can find the constant $c_L$ for different choices of the norm. When computing $c_L$, don't forget the factor of $\frac{1}{k!}$!

By fiddling with functions a bit, we can show these bounds are indeed sharp.

\begin{eg}
  Consider our previous example where
  \[
    e_L(f) = f(\beta) - f(\alpha) - \frac{\beta - \alpha}{2} (f'(\beta) + f'(\alpha)),
  \]
  with exactness up to polynomials of degree $2$. We wlog assume $\alpha < \beta$. Then
  \[
    K(\theta) = e_L((x - \theta)_+^2) = (\beta - \theta)_+^2 - (\alpha - \theta)_+^2 - \frac{\beta}{\alpha}((\beta - \theta)_+ + (\alpha - \theta)_+).
  \]
  Hence we get
  \[
    K(\theta) =
    \begin{cases}
      0 & a \leq \theta \leq \alpha\\
      (\alpha - \theta)(\beta - \theta) & \alpha \leq \theta \leq \beta\\
      0 & \beta \leq \theta \leq b.
    \end{cases}
  \]
  Hence we know
  \[
    e_L(f) = \frac{1}{2}\int_\alpha^\beta (\alpha - \theta)(\beta - \theta) f'''(\theta) \;\d \theta
  \]
  for all $f \in C^3[a, b]$.
\end{eg}

If $K$ does not change sign on $[a, b]$, then the bound
\[
  |\lambda(f)| \leq \left|\frac{1}{k!} \int_a^b K(\theta) \;\d \theta\right| \|f^{(k + 1)}\|_\infty
\]
can be achieved by $x^{k + 1}$, since this has constant $k + 1$th derivative.

Also, if $K$ doesn't change sign, we can use the integral mean value theorem to get the bound
\[
  \lambda (f) = \frac{1}{k!} \left(\int_a^b K(\theta)\;\d \theta\right) f^{(k + 1)}(\xi),
\]
where $\xi \in (a, b)$ depends on $f$.

\begin{eg}
  Continuing our previous example, we see that $K(\theta) \leq 0$ on $[a, b]$, and
  \[
    \int_a^b K(\theta)\;\d \theta = -\frac{1}{6}(\beta - \alpha)^3.
  \]
  Hence we have the bound
  \[
    |e_L(f)| \leq \frac{1}{12}(\beta - \alpha)^3 \|f'''\|_{\infty},
  \]
  and this bound is achieved for $x^3$. We also have
  \[
    e_L(f) = -\frac{1}{12}(\beta - \alpha)^3 f'''(\xi)
  \]
  for some $f$-dependent value of some $\xi \in (a, b)$.
\end{eg}

The conclusion we have is that if $e_L(f) = 0$ for all $f \in P_k[x]$, then we know
\[
  e_L(f) = \frac{1}{k!} \int_a^b K(\theta) f^{(k + 1)}(\theta)\;\d \theta
\]
for all $f \in C^{k + 1}[a, b]$. But for all $j = 0, \cdots, k = 1$, we also have $e_L(f)$ for all $f \in P_j[x]$. So we get
\[
  e_L(f) = \frac{1}{j!} \int_a^b K_j (\theta) f^{(j + 1)}(\theta)\;\d \theta
\]
for all $f \in C^{j + 1}[a, b]$. Note that we have a different kernel.

In general, this might not be a good idea, since we are throwing information away. Yet, this can be helpful if we get some less smooth functions that don't have $k + 1$ derivatives.

This is the end of the first part.

\section{Ordinary differential equations}
\subsection{Introduction}
Suppose we have a system of differential equation
\[
  \mathbf{y}'(t) = \mathbf{f}(t, \mathbf{y}(t))
\]
for $0 \leq t \leq T$, with initial conditions
\[
  \mathbf{y}(0) = \mathbf{y}_0.
\]
The data we have is the function $\mathbf{f}: \R \times \R^N \to \R^N$, the ending time $T > 0$, and the initial condition $\mathbf{y}_0 \in \R^n$. What we seek is the function $\mathbf{y}: [0, T] \to \R^N$.

For a unique solution to exist, we not only need $\mathbf{f}$ to be continuous, but Lipschitz.
\begin{defi}[Lipschitz function]
  A function is \emph{Lipschitz with Lipschitz constant $\lambda \geq 0$} if
  \[
    \|\mathbf{f}(t, \mathbf{x}) - f(t, \hat{\mathbf{x}})\| \leq \lambda \|\mathbf{x} - \hat{\mathbf{x}}\|
  \]
  for all $t \in [0, T]$ and $\mathbf{x}, \hat{\mathbf{x}} \in \R^N$.

  A function is \emph{Lipschitz} if it is Lipschitz with Lipschitz constant $\lambda$ for some $\lambda$.
\end{defi}
It doesn't really matter what norm we pick. It will just change the $\lambda$. The importance is the existence of a $\lambda$.

A special case is when $\lambda = 0$, ie. $\mathbf{f}$ does not depend on $\mathbf{x}$. This is just integration, and is usually easy. This is a convenient test case --- if our numerical approximation does not even work for these problems, then it's pretty useless.

Being Lipschitz is sufficient for existence and uniqueness of solution. An extra assumption we will often make is that $\mathbf{f}$ can be expanded in a Taylor series to as many degrees as we want, since this is convenient.

What do we actually do here? We are not trying to actually integrate and find a formula for the solution $\mathbf{y}$. Instead, we want to solve it numerically. We choose a small time step $h > 0$, and construct approximations
\[
  \mathbf{y}_n \approx \mathbf{y}(t_n),\quad n = 1, 2, \cdots,
\]
with $t_n = nh$. In particular, $t_n - t_{n - 1} = h$ and is always constant. In practice, this restriction is useless, but theoretically it is more complicated to consider varying time step.

If we make $h$ smaller, then we will of course make finer approximations. However, this is more computationally demanding. So we want to study the behaviour of numerical methods in order to figure out what $h$ we should pick.

\subsection{One-step methods}
The simplest type of methods is the one-step ones.

\begin{defi}[(Explicit) one-step method]
  A numerical method is \emph{(explicit) one-step} if $\mathbf{y}_{n + 1}$ depends only on $t_n$ and $\mathbf{y}_n$, ie.
  \[
    \mathbf{y}_{n + 1} = \boldsymbol\phi_h(t_n, \mathbf{y}_n)
  \]
  for some function $\boldsymbol\phi_h: \R \times \R^N \to \R^N$.
\end{defi}
We will later see what ``explicit'' means.

We now see an example of a one-step method. This is the simplest type of one-step method.
\begin{eg}[Euler's method]
  Euler's method has
  \[
    \mathbf{y}_{n + 1} = \mathbf{y}_n + h\mathbf{f}(t_n, \mathbf{y}_n).
  \]
\end{eg}

\end{document}
